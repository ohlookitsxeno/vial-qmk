 /* Copyright 2020 Josef Adamcik
  * Modification for VIA support and RGB underglow by Jens Bonk-Wiltfang
  * 
  * This program is free software: you can redistribute it and/or modify 
  * it under the terms of the GNU General Public License as published by 
  * the Free Software Foundation, either version 2 of the License, or 
  * (at your option) any later version. 
  * 
  * This program is distributed in the hope that it will be useful, 
  * but WITHOUT ANY WARRANTY; without even the implied warranty of 
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
  * GNU General Public License for more details. 
  * 
  * You should have received a copy of the GNU General Public License 
  * along with this program.  If not, see <http://www.gnu.org/licenses/>. 
  */ 

//Sets up what the OLED screens display.

#ifdef OLED_ENABLE

bool left = false;
bool right = false;

bool vleft = false;
bool vright = false;
bool accent = false;

bool is_alternating = false;

uint8_t mapping_table[64];
uint8_t wpm_history[32] = {0};  // Array to store WPM values
uint16_t last_wpm_update = 0;
uint8_t lastpose = 8;
uint8_t pose = 0;
uint16_t left_key_time = 0;
uint16_t right_key_time = 0;
uint16_t alternate_toggle_time = 0;
uint8_t keytime = 160; 

static void render_right(void) {
    oled_clear();
    static const char logo [] PROGMEM = {
        // 'test', 32x16px
        0x00, 0x00, 0xf8, 0x04, 0xf4, 0xf4, 0xf4, 0xf4, 0x34, 0x14, 0x94, 0xd4, 0xd4, 0x14, 0xb4, 0xf4, 
0x34, 0xf4, 0xf4, 0xf4, 0x14, 0x14, 0x74, 0xf4, 0xf4, 0xf4, 0xf4, 0xf4, 0x04, 0xf8, 0x00, 0x00, 
0x00, 0x00, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0x80, 0xb8, 0xb9, 0x99, 0xda, 0xc2, 0xe7, 0xff, 
0xf0, 0xc1, 0xc7, 0xcf, 0xc0, 0xe0, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0x00, 0x00, 
0x00, 0x00, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0x01, 0x01, 0x1f, 0x47, 0x63, 0xf9, 0xfc, 0xff, 
0xff, 0x00, 0x00, 0x9e, 0x9e, 0x8c, 0x61, 0x79, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0x00, 0x00, 
0x00, 0x00, 0x1f, 0x20, 0x2f, 0x2f, 0x2f, 0x2f, 0x28, 0x28, 0x2f, 0x2e, 0x2c, 0x28, 0x29, 0x2f, 
0x2f, 0x28, 0x2b, 0x29, 0x29, 0x2c, 0x2c, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x20, 0x1f, 0x00, 0x00
    };

    oled_set_cursor(0, 0);
    oled_write_raw_P(logo, sizeof(logo));

    // Display "LAYER" and "layer" at lines 5 and 6
    oled_set_cursor(0, 5);
    oled_write_P(PSTR("LAYER"), false);
    oled_set_cursor(0, 6);
    oled_write_P(PSTR("layer"), false);

    // Layer names array with uppercase and lowercase variants
    const char* layers_upper[] = { " ONE", " TWO", "THREE", "FOUR" };
    const char* layers_lower[] = { " one", " two", "three", "four" };
    uint8_t layer = get_highest_layer(layer_state);

    // Display top and bottom parts of the layer name
    oled_set_cursor(0, 7);
    oled_write(layers_upper[layer], false);
    oled_set_cursor(0, 8);
    oled_write(layers_lower[layer], false);

    // Caps Lock indicator, using LED state to control visibility
    oled_set_cursor(0, 11);
    led_t led_usb_state = host_keyboard_led_state();
    oled_write_P(PSTR("CPSLK"), led_usb_state.caps_lock);
    oled_set_cursor(0, 12);
    oled_write_P(PSTR("cpslk"), led_usb_state.caps_lock);
}

const uint8_t rhettfont[] PROGMEM = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0xC0,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x80, 0x80, 0xC0, 0x40, 0x60,
    0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x40, 0x9F, 0x78, 0xC0, 0x80, 0x00, 0xC0,
    0xE0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xE6, 0xE6,
    0xC4, 0x7F, 0xFC, 0xF8, 0xF0, 0x00, 0x00, 0x00,
    0xE0, 0xF1, 0x73, 0xFF, 0xFC, 0xED, 0x45, 0x84,
    0x20, 0xF1, 0x73, 0xFF, 0xFC, 0xED, 0x45, 0x84,
    0xE0, 0x30, 0x08, 0x06, 0x83, 0xF1, 0xC0, 0x01,
    0x3E, 0xE0, 0x80, 0x80, 0x80, 0x00, 0x00, 0x7C,
    0x86, 0x03, 0x81, 0xE1, 0xF8, 0xBC, 0x40, 0x38,
    0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xC0, 0x71, 0x17, 0x0C, 0x71, 0x33, 0x23,
    0x27, 0x47, 0x4F, 0x4F, 0x9F, 0x9F, 0x9F, 0x9F,
    0x06, 0x17, 0x23, 0xC1, 0x80, 0x00, 0x80, 0x80,
    0x9F, 0x9F, 0xDF, 0xDE, 0x9E, 0x0E, 0x0F, 0x0E,
    0x98, 0x9F, 0xDF, 0xDE, 0x9E, 0x0E, 0x0F, 0x0E,
    0x03, 0x0E, 0xD8, 0x20, 0x03, 0x07, 0x03, 0x01,
    0x00, 0x00, 0x00, 0x01, 0x03, 0x27, 0x2F, 0x7E,
    0xFF, 0xFF, 0xFC, 0xF0, 0x30, 0x81, 0x83, 0x0E,
    0x78, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0F, 0x09, 0x08, 0x08, 0x10, 0x20, 0x40, 0x80,
    0x00, 0xF0, 0xF8, 0xF8, 0xF9, 0xFE, 0xFD, 0xF1,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xF8, 0x00,
    0xC2, 0x02, 0x02, 0x02, 0x00, 0x00, 0x01, 0x01,
    0x02, 0x02, 0x02, 0x04, 0x08, 0x10, 0x20, 0x7E,
    0xC2, 0x02, 0x02, 0x04, 0x08, 0x10, 0x20, 0x7E,
    0x00, 0x40, 0x9F, 0x78, 0xC0, 0x80, 0x00, 0x40,
    0xA0, 0xD0, 0xD0, 0x60, 0xE0, 0x60, 0xE6, 0xC6,
    0xC4, 0x7F, 0xFC, 0xF8, 0xF0, 0x08, 0x78, 0xF0,
    0x01, 0x03, 0x07, 0x07, 0x0F, 0x0F, 0x0F, 0x0F,
    0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,
    0x87, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x30, 0x18,
    0x87, 0x00, 0x00, 0x00, 0x00, 0x20, 0x30, 0x18,
    0x00, 0xC0, 0x71, 0x17, 0x08, 0x05, 0x02, 0x01,
    0x1F, 0x3F, 0x3F, 0x39, 0xF9, 0x7F, 0x9D, 0x87,
    0x06, 0x07, 0x0B, 0x4D, 0xBE, 0x9F, 0x87, 0x81,
    0x01, 0x83, 0x47, 0x07, 0x8F, 0x8F, 0x0F, 0x4F,
    0x04, 0x00, 0x79, 0x79, 0x01, 0x05, 0x18, 0x30,
    0x01, 0x03, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0F, 0x09, 0x08, 0x08, 0x00, 0x00, 0x04, 0x04,
    0x04, 0x04, 0x04, 0x05, 0x02, 0x00, 0x03, 0x01,
    0x02, 0x02, 0x02, 0x02, 0x00, 0x00, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
    0x03, 0x01, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00,
    0x9F, 0x9F, 0xDF, 0xDE, 0x98, 0x08, 0x0C, 0x0E,
    0x98, 0x9F, 0xDF, 0xDE, 0x98, 0x08, 0x0C, 0x0E,
    0xE0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF4, 0xE5, 0xE6,
    0x00, 0x00, 0x00, 0x01, 0x03, 0xA7, 0x2F, 0x7E,
    0xFF, 0xFF, 0xFC, 0xF0, 0x30, 0x81, 0x43, 0x0E,
    0xA0, 0xD0, 0xD0, 0x60, 0xE0, 0x64, 0xE5, 0xC6,
};

const uint8_t rhett_top[] PROGMEM = {
    0x00, 0x01, 0x02, 0x03, 0x09, 0x0A, 0x0B, 0x0C, 0x12, 0x13, 0x14, 0x15
};

const uint8_t rhett_data[][20] PROGMEM = {
    {0x1C, 0x1D, 0x08, 0x1E, 0x24, 0x25, 0x11, 0x26, 0x2A, 0x2B, 0x2C, 0x2D, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01},
    {0x04, 0x05, 0x07, 0x1E, 0x0D, 0x0E, 0x10, 0x26, 0x16, 0x17, 0x19, 0x2D, 0x01, 0x1F, 0x0C, 0x01, 0x01, 0x01, 0x01, 0x01},
    {0x1C, 0x1D, 0x08, 0x06, 0x24, 0x25, 0x11, 0x0F, 0x2A, 0x2B, 0x1A, 0x18, 0x01, 0x01, 0x01, 0x20, 0x01, 0x01, 0x01, 0x01},
    {0x04, 0x05, 0x07, 0x06, 0x0D, 0x0E, 0x10, 0x0F, 0x16, 0x17, 0x1B, 0x18, 0x01, 0x1F, 0x0C, 0x20, 0x01, 0x01, 0x01, 0x01},
    {0x04, 0x05, 0x07, 0x1E, 0x0D, 0x0E, 0x10, 0x26, 0x16, 0x17, 0x19, 0x2D, 0x01, 0x27, 0x21, 0x01, 0x2E, 0x2F, 0x29, 0x01},
    {0x1C, 0x1D, 0x08, 0x06, 0x24, 0x25, 0x11, 0x0F, 0x2A, 0x2B, 0x1A, 0x18, 0x01, 0x01, 0x22, 0x28, 0x01, 0x01, 0x01, 0x01},
    {0x04, 0x05, 0x07, 0x06, 0x0D, 0x0E, 0x10, 0x0F, 0x16, 0x17, 0x1B, 0x18, 0x01, 0x27, 0x23, 0x28, 0x2E, 0x2F, 0x29, 0x01}
};

void init_mapping_table(void) {
    for (uint8_t i = 0; i < sizeof(mapping_table); i++) {
        mapping_table[i] = i; 
    }
    mapping_table[0x10] = 0x30;
    mapping_table[0x11] = 0x31;
    mapping_table[0x05] = 0x32;
    mapping_table[0x1D] = 0x35;
    mapping_table[0x13] = 0x33;
    mapping_table[0x14] = 0x34;
}
    
//from previously existing bongocat implementation.
void write_bongochar_at_pixel_xy(uint8_t x, uint8_t y, uint8_t data, bool invert){
    uint8_t i, j, temp;
    if(is_alternating)
        data = mapping_table[data];
    for (i = 0; i < 8 ; i++) { // 6 = font width
        temp = pgm_read_byte(&rhettfont[data * 8]+i);
        for (j = 0; j < 8; j++) {  // 8 = font height
            if (temp & 0x01) {
                oled_write_pixel(x + i, y + j, !invert);
            } else {
                oled_write_pixel(x + i, y + j, invert);
            }
            temp >>= 1;
        }
    }
}

void update_wpm_history(void) {
    // Shift values in the history array to make room for the new WPM value
    for (int i = 31; i > 0; i--) {
        wpm_history[i] = wpm_history[i - 1];
    }
    // Add the current WPM to the start of the history
    wpm_history[0] = get_current_wpm();
}

void draw_wpm(void){
    for (int x = 0; x < 32; x++) {
        uint8_t wpm = wpm_history[x];

        // Constrain WPM within the min/max range
        if (wpm < 40) wpm = 40;
        if (wpm > 168) wpm = 160;

        uint8_t y = 30 - ((wpm - 40) / 4);

        oled_write_pixel(31-x, y, true);  // Draw the pixel
    }
}

static void render_left(void) {
    // Print current mode
    oled_clear();
    draw_wpm();
    oled_set_cursor(0,4);
    oled_write_ln_P(PSTR(" WPM"), false);
    oled_set_cursor(0,5);
    oled_write_ln_P(PSTR(" wpm"), false);
    oled_set_cursor(0,6);
    uint8_t wpm = get_current_wpm();
    char wpm_str [] = {0x20, 0x30+(wpm/100), 0x30+((wpm%100)/10),0x30+((wpm%10)), '\0'};
    oled_write(wpm_str, false);
    oled_set_cursor(0,7);
    wpm_str[1] += 0x50;
    wpm_str[2] += 0x50;
    wpm_str[3] += 0x50;
    oled_write(wpm_str, false);

    uint8_t x, y;
    
    for (y = 0; y < 8; y++) {  // Combined range (3 + 5)
        for (x = 0; x < 4; x++) {
            if (y < 3)
                write_bongochar_at_pixel_xy((x * 8), 64 + (y * 8), pgm_read_byte(&rhett_top[(y * 4) + x]), false);
            else
                write_bongochar_at_pixel_xy((x * 8), 64 + (y * 8), pgm_read_byte(&rhett_data[pose][((y - 3) * 4) + x]), false);
        }
    }
    lastpose = pose;
}

oled_rotation_t oled_init_user(oled_rotation_t rotation) {
    init_mapping_table();
    update_wpm_history();
    return OLED_ROTATION_270;
}

bool oled_task_user(void) {
    if (is_keyboard_master()) {
        if (timer_elapsed(last_wpm_update) > 640 && timer_elapsed(left_key_time) > keytime && timer_elapsed(right_key_time) > keytime && !is_alternating) {
            update_wpm_history();             // Update WPM history
            last_wpm_update = timer_read();   // Reset the timer
            lastpose = 8;
        }
        if (pose != lastpose)
            render_left();
    } else {
        render_right();
    }
	return false;
}

void findpose(void){
    pose = (vleft ? 1 : 0) + (vright ? 2 : 0) + (accent && (vleft || vright) ? 3 : 0);
}

bool process_record_user(uint16_t keycode, keyrecord_t *record) {
    accent = (get_mods() & (MOD_BIT(KC_LSFT) | MOD_BIT(KC_RSFT))) || host_keyboard_led_state().caps_lock;
    if (record->event.pressed) {
        bool kbleft = record->event.key.row < MATRIX_ROWS / 2;
        // Alternate between left and right on each key press
        if (is_alternating || (timer_elapsed(left_key_time) < keytime && kbleft) || (timer_elapsed(right_key_time) < keytime && !kbleft)){
            if (!is_alternating){
                is_alternating = true;
                alternate_toggle_time = timer_read();
                last_wpm_update = alternate_toggle_time;
                vleft = kbleft;
                vright = !vleft;
            }
            left_key_time = timer_read();
        }else{
            if (kbleft){
                left = true;
                vleft = left;
                left_key_time = timer_read();
            }else{
                right = true;  
                vright = right;
                right_key_time = timer_read();
            }  
        }
            
    } else {
        if (record->event.key.row < MATRIX_ROWS / 2){
            left = false;
            if(timer_elapsed(left_key_time)  > keytime && !is_alternating)
                vleft = left;
        }else{
            right = false;  
            if(timer_elapsed(right_key_time)  > keytime && !is_alternating)
                vright = right;
        }
    }
    findpose();

    return true;
}
uint8_t altcount = 0;
void matrix_scan_user(void) {
    if(is_alternating){
        if (timer_elapsed(left_key_time) > keytime){
            is_alternating = false;
            vleft = left;
            vright = right;
        }
            
        if (timer_elapsed(alternate_toggle_time) > keytime) {
            vleft = !vleft;
            vright = !vright;
            alternate_toggle_time = timer_read();
            altcount++;
            if(altcount % 4 == 0){
                update_wpm_history();             // Update WPM history
                last_wpm_update = timer_read();
                altcount = 0;
            }
            findpose();
        }
    }else{
        if (timer_elapsed(left_key_time) > keytime) {
            vleft = left;
            findpose(); 
        }
        if (timer_elapsed(right_key_time) > keytime) {
            vright = right;
            findpose(); 
        }
    }
    
}
#endif